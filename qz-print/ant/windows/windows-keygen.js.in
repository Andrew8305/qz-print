/**
 * @author Tres Finocchiaro
 *
 * Copyright (C) 2015 Tres Finocchiaro, QZ Industries
 */

/******************************************************************************
 *                        Windows KeyGen Utility                              *
 ******************************************************************************
 *  Description:                                                              *
 *    1. Creates a self-signed Java Keystore for jetty wss://localhost        *
 *    2. Exports public certificate from Java Keystore                        *
 *    3. Imports into Windows trusted cert store                              *
 *                                                                            *
 *  Depends:                                                                  *
 *    keytool.exe (distributed with jre: http://java.com)                     *
 *                                                                            *
 *  Usage:                                                                    *
 *    > cscript //NoLogo windows-keygen.js                                    *
 *                                                                            *
 *****************************************************************************/

var shell = new ActiveXObject("WScript.shell");
var fso = new ActiveXObject("Scripting.FileSystemObject");

var javaKey = "HKLM\\Software\\JavaSoft\\Java Runtime Environment\\";
var jreHome = getRegValue(javaKey + getRegValue(javaKey + "CurrentVersion") + "\\JavaHome");

// Uses passed-in parameter as install location.  Will fallback to registry if not provided.
var qzInstall = WScript.Arguments.length ? WScript.Arguments(0) : getRegValue("HKLM\\Software\\${socket.name}\\");

if (jreHome == "") {
    die("Can't find JavaHome.  Secure websockets will not work.", true);
}

if (qzInstall == "") {
    die("Can't find ${socket.name} installation path. Secure websockets will not work.", true);
}

var keyTool = jreHome + "\\bin\\keytool.exe";
var keyStore = fixPath("${jks.keystore}");
var derCert = fixPath("${der.cert}");
var password = pw();    // random password hash

var makeKeyStore = "${jks.command}"
    .replace("${jks.keytool}", keyTool)
    .replace("${jks.keystore}", keyStore)
    .replace("${jks.storepass}", password)
    .replace("${jks.keypass}", password);

deleteFile(keyStore);   // remove old, if exists
debug("Creating keystore for secure websockets (this could take a minute)...");
shell.Run(makeKeyStore, 0, true);
verifyExists(keyStore, "Check keystore exists");

var makeDerCert = "${der.command}"
    .replace("${jks.keytool}", keyTool)
    .replace("${jks.keystore}", keyStore)
    .replace("${jks.storepass}", password)
    .replace("${jks.keypass}", password)
    .replace("${der.cert}", derCert);

deleteFile(derCert);    // remove old, if exists
debug("Converting keystore to native certificate...");
shell.Run(makeDerCert, 0, true);
verifyExists(derCert, "Check certificate exists");

debug("Installing native certificate for secure websockets...");
// FIXME: blindly deleting localhost certs is too generic
var deleteDerCert = 'certutil.exe -delstore "${windows.keygen.store}" "localhost"';
var installDerCert = 'certutil.exe -addstore -f "${windows.keygen.store}" "' + derCert + '"';
// FIXME: blindly searching for a localhost cert is too generic
var verifyDerCert = 'certutil.exe -verifystore "${windows.keygen.store}" "localhost}"';

try {
    // Windows Vista or higher
	shell.Run(deleteDerCert, 0, true);
	shell.Run(installDerCert, 0, true);
	verifyExec(verifyDerCert, "Check certificate installed");
} catch (err) {
    // Windows XP or older
	shell.Popup("Automatic certificate installation is not available for this platform.\n" +
		"For secure websockets to function properly:\n\n" +
		"     1.  Navigate to \"" + derCert + "\"\n" +
		"     2.  Click \"Install Certificate...\"\n" +
		"     3.  Click \"Place all certificates in the following store\"\n" +
		"     4.  Browse to \"Trusted Root Certificate Authorities\"\n" +
		"     5.  Click \"Finish\"\n" +
		"     6.  Click \"Yes\" on thumbprint Security Warning\n\n" +
		"Click OK to automatically launch the certificate import wizard now.\n", 0, "Warning - ${socket.name}", 48);

	// Do not wrap quotes around derCert, or this next line will fail
	shell.Run("rundll32.exe cryptext.dll,CryptExtAddCER " + derCert, 1, true);
}

verifyExec(verifyDerCert, "Check certificate installed");

var file = fso.OpenTextFile(fixPath("${jks.properties}"), 2, true);
file.WriteLine("wss.alias=" + "${jks.alias}");
file.WriteLine("wss.keystore=" + keyStore.replace(/\\/g,"\\\\"));
file.WriteLine("wss.keypass=" + password);
file.WriteLine("wss.storepass=" + password);
file.Close();

debug("Registering with Firefox...");

//  Determine if Firefox is installed
var firefoxKey = "HKLM\\Software\\Mozilla\\Mozilla Firefox";
var firefoxVer = getRegValue(firefoxKey + "\\");
if (!firefoxVer) {
    debug(" - [skipped] Firefox was not detected");
    WScript.Quit(0);
} else {
    debug(" - [success] Found Firefox " + firefoxVer);
}

// Determine full path to firefox.exe, i.e. "C:\Program Files (x86)\Mozilla Firefox\firefox.exe"
var firefoxInstall = getRegValue(firefoxKey + " " + firefoxVer + "\\bin\\PathToExe");
var firefoxCfg = firefoxInstall + "\\..\\${firefoxconfig.name}";
var firefoxPrefs = firefoxInstall + "\\..\\defaults\\pref\\${firefoxprefs.name}";

// 1. readPlainCert() reads in certificate, stripping non-base64 content
// 2. writeParsedConfig(...) places config file in same folder as firefox.exe
writeParsedConfig(fixPath("${firefoxconfig.install}"), firefoxCfg, "\\${certData}", readPlainCert(derCert));
verifyExists(firefoxCfg, "Check Firefox config exists");

// Install the preference file tells Firefox to launches ${firefoxconfig.name} each it starts
fso.CopyFile(fixPath("${firefoxprefs.install}"), firefoxPrefs);

WScript.Quit(0);

/**
 * Deletes a file
 */
function deleteFile(filePath) {
	if (fso.FileExists(filePath)) {
		try {
			fso.DeleteFile(filePath);
		} catch (err) {
			die("Unable to delete " + filePath, false);
		}
	}
}

/**
 * Generates a random string to be used as a password
 */
function pw() {
    var text = "";
    var chars = "abcdefghijklmnopqrstuvwxyz0123456789";
    for( var i=0; i < parseInt("${jks.passlength}"); i++ ) {
        text += chars.charAt(Math.floor(Math.random() * chars.length));
	}
    return text;
}

/**
 * Reads a registry value, taking 32-bit/64-bit architecture into consideration
 */
function getRegValue(path) {	
	// If 64-bit OS, try 32-bit registry first
	var arch = "";
	if (shell.ExpandEnvironmentStrings("ProgramFiles(x86)")) {
		path = path.replace("\\Software\\", "\\Software\\Wow6432Node\\");
	}
	
	var regValue = "";
	try {
		regValue = shell.RegRead(path);
	} catch (err) {
		try {
            // Fall back to 64-bit registry
            path = path.replace("\\Software\\Wow6432Node\\", "\\Software\\");
            regValue = shell.RegRead(path);
		} catch (err) {}
	}
	return regValue;
}

/**
 * Displays a message regarding whether or not a file exists
 */
function verifyExists(path, msg) {
    debug(" - " + (fso.FileExists(path) ? "[success] " : "[failed] ") + msg);
}

/**
 * Displays a message regarding whether or not a command succeeded
 */
function verifyExec(cmd, msg) {
    debug(" - " + (shell.Run(cmd, 0, true) == 0 ? "[success] " : "[failed] ")  + msg);
}

/**
 * Replaces "!install" with proper location, usually "C:\Program Files\", fixes forward slashes
 */
function fixPath(append) {
    return append.replace("${jks.install}", qzInstall).replace(/\//g, "\\");
}

/**
 * Displays an error message and exits the script
 * @param msg
 */
function die(msg, block) {
    WScript.Echo("ERROR: " + msg);
    if (block) {
        WScript.Echo("\n\nPress enter to continue");
        WScript.StdIn.Read(0);
        WScript.StdIn.ReadLine();
    }
    WScript.Quit(1);
}

/**
 * Displays a status message
 * @param msg
 */
function debug(msg, block) {
    WScript.Echo(msg);
    if (block) {
        WScript.Echo("\n\nPress enter to continue");
        WScript.StdIn.Read(0);
        WScript.StdIn.ReadLine();
    }
}

/*
 * Reads in a text file, expands the specified variable and writes it back out.
 * Note: Due to regular expressions, special characters must be escaped in the
 * variable name, i.e. "${foo}" should be "\\${foo}"
 */
function writeParsedConfig(inPath, outPath, varName, varData) {
    var inFile = fso.OpenTextFile(inPath, 1, true);     // 1 = ForReading
    var outFile = fso.OpenTextFile(outPath, 2, true);   // 2 = ForWriting
    var re = new RegExp(varName, 'g')
    while(!inFile.AtEndOfStream) {
        outFile.WriteLine(inFile.ReadLine().replace(re, varData));
    }
    inFile.close();
    outFile.close();
}

/*
 * Reads in a X509 certificate, stripping BEGIN, END and NEWLINE string
 */
function readPlainCert(certPath) {
    var certFile = fso.OpenTextFile(certPath, 1, true);
    var certData = "";
    while (!certFile.AtEndOfStream) { certData += strip(certFile.ReadLine()); }
    certFile.close();
    return certData;
}

/*
 * Strips non-base64 data (i.e RFC X509 --START, --END) from a string
 */
function strip(line) {
    var X509 = ["-----BEGIN CERTIFICATE-----", "-----END CERTIFICATE-----", "\r", "\n"];
    for (var i in X509) { line = line.replace(new RegExp(X509[i], 'g'), ''); }
    return line;
}
