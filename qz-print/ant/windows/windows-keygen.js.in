/**
 * @author Tres Finocchiaro
 *
 * Copyright (C) 2015 Tres Finocchiaro, QZ Industries
 */

/******************************************************************************
 *                        Windows KeyGen Utility                              *
 ******************************************************************************
 *  Description:                                                              *
 *    1. Creates a self-signed Java Keystore for jetty wss://localhost        *
 *    2. Exports public certificate from Java Keystore                        *
 *    3. Imports into Windows Trusted Root Certs                              *
 *                                                                            *
 *  Depends:                                                                  *
 *    keytool.exe (distributed with jre: http://java.com)                     *
 *                                                                            *
 *  Usage:                                                                    *
 *    > cscript //NoLogo windows-keygen.js                                    *
 *                                                                            *
 *****************************************************************************/
var shell = new ActiveXObject("WScript.shell");
var fso = new ActiveXObject("Scripting.FileSystemObject");

var javaKey = "HKLM\\Software\\JavaSoft\\Java Runtime Environment\\";
var jreHome = getRegValue(javaKey + getRegValue(javaKey + "CurrentVersion") + "\\JavaHome");

// Uses passed-in parameter as install location.  Will fallback to registry if not provided.
var qzInstall = WScript.Arguments.length ? WScript.Arguments(0) : getRegValue("HKLM\\Software\\${socket.name}\\");

if (jreHome == "") {
    die("Can't find JavaHome.  Secure websockets will not work.", true);
}

if (qzInstall == "") {
    die("Can't find ${socket.name} installation path. Secure websockets will not work.", true);
}

var keyTool = jreHome + "\\bin\\keytool.exe";
var keyStore = fixPath("${jks.keystore}");
var derCert = fixPath("${der.cert}");
var password = pw();    // random password hash

var makeKeyStore = "${jks.command}"
    .replace("${jks.keytool}", keyTool)
    .replace("${jks.keystore}", keyStore)
    .replace("${jks.storepass}", password)
    .replace("${jks.keypass}", password);

deleteFile(keyStore);   // remove old, if exists
debug("Creating keystore for secure websockets...");
shell.Run(makeKeyStore, 0, true);
verifyExists(keyStore, "Check keystore exists");

var makeDerCert = "${der.command}"
    .replace("${jks.keytool}", keyTool)
    .replace("${jks.keystore}", keyStore)
    .replace("${jks.storepass}", password)
    .replace("${jks.keypass}", password)
    .replace("${der.cert}", derCert);

deleteFile(derCert);    // remove old, if exists
debug("Converting keystore to native certificate...");
shell.Run(makeDerCert, 0, true);
verifyExists(derCert, "Check certificate exists");

debug("Installing native certificate for secure websockets...");
var deleteDerCert = 'certutil.exe -delstore "${windows.keygen.store}" "${vendor.company}"';
var installDerCert = 'certutil.exe -addstore -f "${windows.keygen.store}" "' + derCert + '"';
var verifyDerCert = 'certutil.exe -verifystore "${windows.keygen.store}" "${vendor.company}"';

shell.Run(deleteDerCert, 0, true);
shell.Run(installDerCert, 0, true);
verifyExec(verifyDerCert, "Check certificate installed");

var file = fso.OpenTextFile(fixPath("${jks.properties}"), 2, true);
file.WriteLine("wss.alias=" + "${jks.alias}");
file.WriteLine("wss.keystore=" + keyStore);
file.WriteLine("wss.keypass=" + password);
file.WriteLine("wss.storepass=" + password);
file.Close();

/**
 * Deletes a file
 */
function deleteFile(filePath) {
	if (fso.FileExists(filePath)) {
		try {
			fso.DeleteFile(filePath);
		} catch (err) {
			die("Unable to delete " + filePath, false);
		}
	}
}

/**
 * Generates a random string to be used as a password
 */
function pw() {
    var text = "";
    var chars = "abcdefghijklmnopqrstuvwxyz0123456789";
    for( var i=0; i < parseInt("${jks.passlength}"); i++ ) {
        text += chars.charAt(Math.floor(Math.random() * chars.length));
	}
    return text;
}

/**
 * Reads a registry value, taking 32-bit/64-bit architecture into consideration
 */
function getRegValue(path) {	
	// If 64-bit OS, try 32-bit registry first
	var arch = "";
	if (shell.ExpandEnvironmentStrings("ProgramFiles(x86)")) {
		path = path.replace("\\Software\\", "\\Software\\Wow6432Node\\");
	}
	
	var regValue = "";
	try {
		regValue = shell.RegRead(path);
	} catch (err) {
		try {
            // Fall back to 64-bit registry
            path = path.replace("\\Software\\Wow6432Node\\", "\\Software\\");
            regValue = shell.RegRead(path);
		} catch (err) {}
	}
	return regValue;
}

/**
 * Displays a message regarding whether or not a file exists
 */
function verifyExists(path, msg) {
    debug(" - " + msg + (fso.FileExists(path) ? " [success]" : " [failed]"));
}

/**
 * Displays a message regarding whether or not a command succeeded
 */
function verifyExec(cmd, msg) {
    debug(" - " + msg + (shell.Run(cmd, 0, true) == 0 ? " [success]" : " [failed]"));
}

/**
 * Replaces "!install" with proper location, usually "C:\Program Files\", fixes forward slashes
 */
function fixPath(append) {
    return append.replace("${jks.install}", qzInstall).replace(/\//g, "\\");
}

/**
 * Displays an error message and exits the script
 * @param msg
 */
function die(msg, block) {
    WScript.Echo("ERROR: " + msg);
    if (block) {
        WScript.Echo("\n\nPress enter to continue");
        WScript.StdIn.Read(0);
        WScript.StdIn.ReadLine();
    }
    WScript.Quit(1);
}

/**
 * Displays a status message
 * @param msg
 */
function debug(msg, block) {
    WScript.Echo(msg);
    if (block) {
        WScript.Echo("\n\nPress enter to continue");
        WScript.StdIn.Read(0);
        WScript.StdIn.ReadLine();
    }
}
